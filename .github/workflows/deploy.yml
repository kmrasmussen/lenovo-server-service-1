# This is the name of the workflow.
name: 'Deploy to Servers'

# This section defines when the workflow will run.
on:
  push:
    branches: [ staging, master ]

# This section defines the jobs to be run.
jobs:
  # JOB 1: SETUP THE MATRIX
  # This job's only purpose is to determine which server list to use based on the branch
  # and output it for the next job.
  setup-matrix:
    runs-on: ubuntu-latest
    outputs:
      # Define an output named 'server_list'
      server_list: ${{ steps.set-matrix.outputs.server_list }}
    steps:
      - id: set-matrix
        name: Determine Server Matrix
        run: |
          if [[ "${{ github.ref_name }}" == "staging" ]]; then
            echo "Using staging server list"
            echo 'server_list={"server":[{"host":"lenovo-ssh.intercebd.com","user":"lenovouser"}]}' >> $GITHUB_OUTPUT
          else
            echo "Using production server list"
            echo 'server_list={"server":[{"host":"dell-ssh.intercebd.com","user":"delluser"}]}' >> $GITHUB_OUTPUT
          fi

  # JOB 2: DEPLOY
  # This job will now run after the setup job is complete.
  deploy:
    # It requires 'setup-matrix' to finish successfully before it starts.
    needs: setup-matrix
    name: Deploy to ${{ github.ref_name == 'staging' && 'Staging' || 'Production' }}
    runs-on: ubuntu-latest
    
    # Dynamically select the environment based on the branch.
    environment: ${{ github.ref_name == 'staging' && 'test' || 'production1' }}
    
    strategy:
      fail-fast: false
      # THE MATRIX IS NOW BUILT FROM THE OUTPUT OF THE PREVIOUS JOB
      # This syntax is valid and robust.
      matrix: ${{ fromJSON(needs.setup-matrix.outputs.server_list) }}

    # The rest of your steps remain exactly the same.
    steps:
      - name: Create env file
        run: |
          cat > .env << 'EOF'
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          AUTH_SECRET=${{ secrets.AUTH_SECRET }}
          NEXTAUTH_URL=${{ secrets.NEXTAUTH_URL }}
          NEXT_PUBLIC_VAPID_PUBLIC_KEY=${{ secrets.NEXT_PUBLIC_VAPID_PUBLIC_KEY }}
          VAPID_PRIVATE_KEY=${{ secrets.VAPID_PRIVATE_KEY }}
          AUTH_GOOGLE_ID=${{ secrets.AUTH_GOOGLE_ID }}
          AUTH_GOOGLE_SECRET=${{ secrets.AUTH_GOOGLE_SECRET }}
          OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
          OPENROUTER_API_KEY=${{ secrets.OPENROUTER_API_KEY }}
          AWS_S3_ACCESS_KEY=${{ secrets.AWS_S3_ACCESS_KEY }}
          AWS_S3_SECRET_ACCESS_KEY=${{ secrets.AWS_S3_SECRET_ACCESS_KEY }}
          AWS_REGION=${{ secrets.AWS_REGION }}
          S3_BUCKET_NAME=${{ secrets.S3_BUCKET_NAME }}
          GOOGLE_GEOCODING_API=${{ secrets.GOOGLE_GEOCODING_API }}
          MOONDREAM_API_KEY=${{ secrets.MOONDREAM_API_KEY }}
          GRAFANA_ADMIN_USER=${{ secrets.GRAFANA_ADMIN_USER }}
          GRAFANA_ADMIN_PASSWORD=${{ secrets.GRAFANA_ADMIN_PASSWORD}}
          HYPERSTACK_API_KEY=${{ secrets.HYPERSTACK_API_KEY }}
          MAX_SPINNED_UP=${{ secrets.MAX_SPINNED_UP }}
          HYPERSTACK_ADMIN_TOKEN=${{ secrets.HYPERSTACK_ADMIN_TOKEN }}
          HYPERSTACK_SPINUP_PERMISSION_TOKEN=${{ secrets.HYPERSTACK_SPINUP_PERMISSION_TOKEN }}
          EOF

      - name: Validate env file
        run: |
          while IFS= read -r line; do
            if [[ $line == *"="* ]]; then
              key=$(echo "$line" | cut -d'=' -f1)
              value=$(echo "$line" | cut -d'=' -f2-)
              if [[ -z "$value" ]]; then
                echo "❌ $key is empty"
                exit 1
              fi
              echo "✅ $key is set"
            fi
          done < .env
      
      - name: Install cloudflared
        run: |
          wget https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared-linux-amd64.deb
      
      - name: Deploy to ${{ matrix.server.host }}
        env:
          CF_ACCESS_CLIENT_ID: ${{ secrets.CLOUDFLARE_SERVICE_TOKEN_ID }}
          CF_ACCESS_CLIENT_SECRET: ${{ secrets.CLOUDFLARE_SERVICE_TOKEN_SECRET }}
        run: |
          echo "${{ secrets.SERVER_SSH_KEY }}" > ssh_key
          chmod 600 ssh_key

          REMOTE_USER_HOST="${{ matrix.server.user }}@${{ matrix.server.host }}"

          scp -i ssh_key \
              -o StrictHostKeyChecking=no \
              -o ProxyCommand="cloudflared access ssh --hostname ${{ matrix.server.host }}" \
              .env "$REMOTE_USER_HOST:~/."
          
          ssh -i ssh_key \
              -o StrictHostKeyChecking=no \
              -o ServerAliveInterval=60 \
              -o ServerAliveCountMax=10 \
              -o ProxyCommand="cloudflared access ssh --hostname ${{ matrix.server.host }}" \
              "$REMOTE_USER_HOST" << 'EOF'
            set -e
            mkdir -p ~/deployed
            cd ~/deployed/lenovo-server-service-1 || git clone https://github.com/kmrasmussen/lenovo-server-service-1.git ~/deployed/lenovo-server-service-1
            cd ~/deployed/lenovo-server-service-1
            git config pull.rebase true
            git pull origin ${{ github.ref_name }}
            mv ~/.env .
            docker compose build
            echo "Pre-pulling Docker images..."
            docker compose pull --ignore-pull-failures || true
            docker compose up -d --remove-orphans
            docker image prune -f --filter "dangling=true"
          EOF
